"""
Import command to ingest legacy CSV exports into the Django models.
"""

from __future__ import annotations

import csv
from datetime import datetime, date
from pathlib import Path
from typing import Any

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from django.utils import timezone

from core import models


class Command(BaseCommand):
    help = "Import a CSV file generated by steam_daily.py into the Django database."

    def add_arguments(self, parser):
        parser.add_argument("csv_path", help="Path to the CSV file to ingest.")
        parser.add_argument(
            "--source-name",
            default="steam_daily",
            help="Identifier for the crawler that produced the CSV.",
        )
        parser.add_argument(
            "--ingested-date",
            dest="ingested_date",
            help="Business date for this import (YYYY-MM-DD). Defaults to file stem or today.",
        )
        parser.add_argument(
            "--dry-run",
            action="store_true",
            help="Parse and log actions without writing to the database.",
        )

    def handle(self, *args, **options):
        csv_path = Path(options["csv_path"]).expanduser()
        if not csv_path.exists():
            raise CommandError(f"CSV file not found: {csv_path}")

        ingested_date = self._resolve_ingested_date(csv_path, options.get("ingested_date"))
        source_name = options["source_name"]
        dry_run = options["dry_run"]

        self.stdout.write(f"Importing {csv_path} for {ingested_date} (source: {source_name})")

        with csv_path.open("r", encoding="utf-8-sig") as fh:
            reader = csv.DictReader(fh)
            rows = list(reader)

        if not rows:
            self.stdout.write(self.style.WARNING("No rows detected, nothing to do."))
            return

        if dry_run:
            self.stdout.write(f"[dry-run] Would process {len(rows)} rows.")
            return

        with transaction.atomic():
            batch = models.DiscoveryBatch.objects.create(
                source_name=source_name,
                run_started_at=timezone.now(),
                ingested_for_date=ingested_date,
                source_file=str(csv_path),
                parameters={"fieldnames": reader.fieldnames},
            )
            self._ingest_rows(batch, rows)
            batch.run_completed_at = timezone.now()
            batch.save(update_fields=["run_completed_at"])

        self.stdout.write(self.style.SUCCESS(f"Ingested {len(rows)} rows into batch {batch.id}"))

    def _resolve_ingested_date(self, csv_path: Path, override: str | None) -> date:
        if override:
            try:
                return datetime.strptime(override, "%Y-%m-%d").date()
            except ValueError as exc:
                raise CommandError(f"Invalid --ingested-date value: {override}") from exc

        # Try to infer from filename, e.g. new_games_2025-08-21.csv
        stem = csv_path.stem
        for token in stem.split("_"):
            try:
                return datetime.strptime(token, "%Y-%m-%d").date()
            except ValueError:
                continue
        return date.today()

    def _ingest_rows(self, batch: models.DiscoveryBatch, rows: list[dict[str, Any]]) -> None:
        for row in rows:
            steam_appid = row.get("steam_appid")
            if not steam_appid:
                continue

            try:
                steam_id = int(steam_appid)
            except (TypeError, ValueError):
                self.stdout.write(self.style.WARNING(f"Skipping invalid appid: {steam_appid}"))
                continue

            game, _ = models.Game.objects.get_or_create(
                steam_appid=steam_id,
                defaults={
                    "name": row.get("name", "").strip() or f"App {steam_appid}",
                    "steam_url": row.get("steam_url", ""),
                },
            )

            # Update canonical fields with latest data
            game.name = row.get("name", game.name) or game.name
            game.steam_url = row.get("steam_url", game.steam_url)
            game.website = row.get("website", game.website or "")
            game.developers = row.get("developers", game.developers or "")
            game.publishers = row.get("publishers", game.publishers or "")
            game.categories = row.get("categories", game.categories or "")
            game.genres = row.get("genres", game.genres or "")
            tag_value = row.get("target_tags_found") or row.get("tag_category") or game.tags or ""
            game.tags = tag_value
            game.latest_release_date = row.get("release_date", game.latest_release_date or "")
            game.latest_detection_stage = row.get("detection_stage", game.latest_detection_stage or "")
            game.latest_api_response_type = row.get("api_response_type", game.latest_api_response_type or "")
            game.save()

            snapshot = models.GameSnapshot.objects.create(
                game=game,
                batch=batch,
                detection_stage=row.get("detection_stage", ""),
                api_response_type=row.get("api_response_type", ""),
                potential_duplicate=str(row.get("potential_duplicate", "")).lower() in {"true", "1", "yes"},
                discovery_date=self._parse_date(row.get("discovery_date")),
                ingested_for_date=batch.ingested_for_date,
                release_date_raw=row.get("release_date", ""),
                description=row.get("description", ""),
                supported_languages=row.get("supported_languages", ""),
                followers=self._parse_int(row.get("followers")),
                wishlists_est=self._parse_int(row.get("wishlists_est")),
                wishlist_rank=self._parse_int(row.get("wishlist_rank")),
                source_categories=row.get("categories", ""),
                source_genres=row.get("genres", ""),
                source_tags=row.get("target_tags_found", ""),
                raw_payload=row,
            )

            # Optional: link swipe actions to batch later if needed
            _ = snapshot  # silence lint warnings

    def _parse_int(self, value: Any) -> int | None:
        if value in (None, "", "None"):
            return None
        try:
            return int(value)
        except (TypeError, ValueError):
            return None

    def _parse_date(self, value: str | None):
        if not value:
            return None
        for fmt in ("%Y-%m-%d", "%Y/%m/%d"):
            try:
                return datetime.strptime(value, fmt).date()
            except ValueError:
                continue
        return None
